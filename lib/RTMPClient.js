const ffmpeg = require('fluent-ffmpeg')
const logger = require('./logger')('rtmp-client')
const path = require('path')
const fs = require('fs')

class RTMPClient {
  constructor (streamURL, streamKey) {
    this.streamURL = streamURL
    this.streamKey = streamKey
  }

  async pushFolder (videoFolderPath) {
    let outputPath = (this.streamURL + this.streamKey)
    let fileList = fs.readdirSync(videoFolderPath)
    let ffmpegCLI = ffmpeg()
    let complexFilter = []
    let middleStreams = []
    ffmpegCLI = ffmpegCLI.addOption('-fflags', '+genpts')
    // ffmpegCLI = ffmpegCLI.addOption('-threads', '4')
    for (let index in fileList) {
      ffmpegCLI = ffmpegCLI.addInput(path.join(videoFolderPath, fileList[index]))
      // It is useful for real-time output. This option will slow down the reading of the input(s) to the native frame rate of the input(s)
      ffmpegCLI = ffmpegCLI.native() // .inputOptions('-re')
      // generated by the size function and autopad function
      complexFilter.push({
        filter: 'scale',
        options: {
          w: 'if(gt(a,1.7777777777777777),1280,trunc(720*a/2)*2)',
          h: 'if(lt(a,1.7777777777777777),720,trunc(1280/a/2)*2)'
        },
        inputs: `${index}:v`,
        outputs: `rescaled${index}`
      })
      complexFilter.push({
        filter: 'pad',
        options: {
          w: 1280,
          h: 720,
          x: 'if(gt(a,1.7777777777777777),0,(1280-iw)/2)',
          y: 'if(lt(a,1.7777777777777777),0,(720-ih)/2)',
          color: 'black'
        },
        inputs: `rescaled${index}`,
        outputs: `padded${index}`
      })
      complexFilter.push({
        filter: 'drawtext',
        // options: `fontfile=./lib/unicode.ttf:text=${path.basename(fileList[index])}:fontcolor=black:fontsize=16:box=1:boxcolor=white@0.2:boxborderw=5:x=5:y=5`,
        options: `fontfile=${path.join(__dirname, './unicode.ttf')}:text=${path.basename(fileList[index])}:fontcolor=black:fontsize=16:box=1:boxcolor=white@0.2:boxborderw=5:x=5:y=5`,
        inputs: `padded${index}`,
        outputs: `text${index}`
      })
      middleStreams.push(`text${index}`)
      middleStreams.push(`${index}:a`)
    }
    complexFilter.push({
      filter: 'concat',
      options: {
        n: fileList.length,
        v: 1,
        a: 1
      },
      inputs: middleStreams,
      outputs: [`outputv`, 'outputa']
    })
    // Set the number of audio channels
    // Seems useless for video file
    // ffmpegCLI = ffmpegCLI.audioChannels(2) // .inputOptions('-ac 2')
    // Set the video/audio codec
    ffmpegCLI = ffmpegCLI.videoCodec('libx264')
    ffmpegCLI = ffmpegCLI.audioCodec('libmp3lame')
    // Set the audio frequency
    // Seems useless for video file
    // ffmpegCLI = ffmpegCLI.audioFrequency(44100)
    // Output format flv for streaming
    ffmpegCLI = ffmpegCLI.format('flv')
    // Additional Video Option
    ffmpegCLI = ffmpegCLI.addOptions([
      // x264 option
      '-preset veryfast',
      '-crf 23',
      '-maxrate 2500k',
      '-bufsize 2500k'
    ])
    ffmpegCLI = ffmpegCLI.complexFilter(complexFilter, [`outputv`, `outputa`])
    ffmpegCLI = ffmpegCLI.output(outputPath, {end: false})
    return new Promise((resolve, reject) => {
      ffmpegCLI.on('start', (commandLine) => {
        logger.info(`Spawned Ffmpeg with command: ${commandLine}`)
        logger.info(`Video ${videoFolderPath} is Pushing `)
      })
      .on('error', (err, stdout, stderr) => {
        logger.error('error: ' + err.message)
        logger.error('stdout: ' + stdout)
        logger.error('stderr: ' + stderr)
        reject(err)
      })
      .on('stderr', (stderrLine) => {
        logger.trace(stderrLine)
      })
      .on('end', () => {
        logger.info(`Video ${videoFolderPath}  Pushing is Finished !`)
        resolve()
      })
      .run()
    })
  }

  async push (videoFilePath) {
    let outputPath = (this.streamURL + this.streamKey)
    let ffmpegCLI = ffmpeg().addInput(videoFilePath)
    // It is useful for real-time output. This option will slow down the reading of the input(s) to the native frame rate of the input(s)
    ffmpegCLI = ffmpegCLI.native() // .inputOptions('-re')
    // Set the number of audio channels
    ffmpegCLI = ffmpegCLI.audioChannels(2) // .inputOptions('-ac 2')
    // Rescale the video to 720p, auto padding the remaining parts
    ffmpegCLI = ffmpegCLI.size('1280x720').autoPad()
    // Set the video/audio codec
    ffmpegCLI = ffmpegCLI.videoCodec('libx264')
    ffmpegCLI = ffmpegCLI.audioCodec('libmp3lame')
    // Set the audio frequency
    ffmpegCLI = ffmpegCLI.audioFrequency(44100)
    // Output format fiv for streaming
    ffmpegCLI = ffmpegCLI.format('flv')
    // Additional Video Option
    ffmpegCLI = ffmpegCLI.addOptions([
      // x264 option
      '-preset veryfast',
      '-crf 23',
      '-maxrate 2500k',
      '-bufsize 2500k'
    ])
    ffmpegCLI = ffmpegCLI.videoFilters([{
      filter: 'drawtext',
      options: `fontfile=${path.join(__dirname, './unicode.ttf')}:text=${path.basename(videoFilePath)}:fontcolor=black:fontsize=16:box=1:boxcolor=white@0.2:boxborderw=5:x=5:y=5`
    }])
    ffmpegCLI = ffmpegCLI.output(outputPath, {end: false})
    return new Promise((resolve, reject) => {
      ffmpegCLI.on('start', (commandLine) => {
        logger.info(`Spawned Ffmpeg with command: ${commandLine}`)
        logger.info(`Video ${videoFilePath} is Pushing `)
      })
      .on('error', (err, stdout, stderr) => {
        logger.error('error: ' + err.message)
        logger.error('stdout: ' + stdout)
        logger.error('stderr: ' + stderr)
        reject(err)
      })
      .on('stderr', (stderrLine) => {
        logger.trace(stderrLine)
      })
      .on('end', () => {
        logger.info(`Video ${videoFilePath}  Pushing is Finished !`)
        resolve()
      })
      .run()
    })
  }

  async copy (InputStream) {
    let outputPath = (this.streamURL + this.streamKey)
    let ffmpegCLI = ffmpeg().addInput(InputStream)
    // It is useful for real-time output. This option will slow down the reading of the input(s) to the native frame rate of the input(s)
    ffmpegCLI = ffmpegCLI.native() // .inputOptions('-re')
    // Set the number of audio channels
    // ffmpegCLI = ffmpegCLI.audioChannels(2) // .inputOptions('-ac 2')
    // Rescale the video to 720p, auto padding the remaining parts
    // ffmpegCLI = ffmpegCLI.size('1280x720').autoPad()
    // Set the video/audio codec
    ffmpegCLI = ffmpegCLI.videoCodec('copy')
    ffmpegCLI = ffmpegCLI.audioCodec('copy')
    // Set the audio frequency
    // ffmpegCLI = ffmpegCLI.audioFrequency(44100)
    // Output format fiv for streaming
    ffmpegCLI = ffmpegCLI.format('flv')
    // Additional Video Option
    // ffmpegCLI = ffmpegCLI.addOptions([
    //   // x264 option
    //   '-preset veryfast',
    //   '-crf 23',
    //   '-maxrate 2500k',
    //   '-bufsize 2500k'
    // ])
    // ffmpegCLI = ffmpegCLI.videoFilters([{
    //   filter: 'drawtext',
    //   options: `fontfile=${path.join(__dirname, './unicode.ttf')}:text=${path.basename(videoFilePath)}:fontcolor=black:fontsize=16:box=1:boxcolor=white@0.2:boxborderw=5:x=5:y=5`
    // }])
    ffmpegCLI = ffmpegCLI.output(outputPath, {end: false})
    return new Promise((resolve, reject) => {
      ffmpegCLI.on('start', (commandLine) => {
        logger.info(`Spawned Ffmpeg with command: ${commandLine}`)
        logger.info(`Video ${InputStream} is Pushing `)
      })
      .on('error', (err, stdout, stderr) => {
        logger.error('error: ' + err.message)
        logger.error('stdout: ' + stdout)
        logger.error('stderr: ' + stderr)
        reject(err)
      })
      .on('stderr', (stderrLine) => {
        logger.trace(stderrLine)
      })
      .on('end', () => {
        logger.info(`Video ${InputStream}  Pushing is Finished !`)
        resolve()
      })
      .run()
    })
  }
}

module.exports = RTMPClient
